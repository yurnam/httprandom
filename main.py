from flask import Flask, request
import json
import llmintegrator

app = Flask(__name__)

# Optional: keep requests small so you don't accidentally feed megabytes into the model
app.config["MAX_CONTENT_LENGTH"] = 256 * 1024  # 256 KiB

llm = llmintegrator.LLMIntegrator()
llm.model_name = "llama3.1:8b"

REMOVE_PATTERNS = [
    "```html", "```HTML", "```",  # common fences
]

def _safe_decode(b: bytes, limit: int = 64_000) -> str:
    """Decode bytes to text safely, bounded."""
    if not b:
        return ""
    b = b[:limit]
    try:
        return b.decode("utf-8", errors="replace")
    except Exception:
        return repr(b)

def _pretty(obj) -> str:
    try:
        return json.dumps(obj, indent=2, sort_keys=True, ensure_ascii=False)
    except Exception:
        return repr(obj)

def build_request_dump() -> str:
    # Full URL includes query string; root_path can matter behind reverse proxies.
    full_path = request.full_path  # includes ?query=... and ends with trailing ? if no query
    if full_path.endswith("?"):
        full_path = full_path[:-1]

    headers = {k: v for k, v in request.headers.items()}

    # Raw body (bounded). You can also include request.data directly (it caches).
    raw_body = request.get_data(cache=True)  # bytes
    raw_body_text = _safe_decode(raw_body)

    # Parsed bodies
    json_body = None
    json_error = None
    if request.is_json:
        try:
            json_body = request.get_json(silent=False)
        except Exception as e:
            json_error = f"{type(e).__name__}: {e}"

    form = request.form.to_dict(flat=False)  # keep multi-values
    files = {k: {"filename": f.filename, "content_type": f.content_type}
             for k, f in request.files.items()}

    dump = {
        "request_line": {
            "method": request.method,
            "path": request.path,
            "full_path": full_path,
            "query_string_raw": request.query_string.decode("utf-8", errors="replace"),
            "url": request.url,
            "base_url": request.base_url,
            "scheme": request.scheme,
            "protocol": request.environ.get("SERVER_PROTOCOL"),
        },
        "client": {
            "remote_addr": request.remote_addr,
            "access_route": request.access_route,
        },
        "routing": {
            "endpoint": request.endpoint,
            "blueprint": request.blueprint,
            "view_args": request.view_args,
        },
        "content": {
            "content_type": request.content_type,
            "mimetype": request.mimetype,
            "content_length": request.content_length,
        },
        "headers": headers,
        "cookies": request.cookies,
        "args": request.args.to_dict(flat=False),
        "form": form,
        "files": files,
        "json": json_body,
        "json_error": json_error,
        "raw_body_preview": raw_body_text,  # bounded to 64k by _safe_decode
    }

    # Optionally include a small selection of WSGI environ keys (can be huge; keep it tight)
    environ_subset_keys = [
        "HTTP_HOST", "REMOTE_PORT", "SERVER_NAME", "SERVER_PORT",
        "wsgi.url_scheme", "REQUEST_URI",
    ]
    env_subset = {}
    for k in environ_subset_keys:
        v = request.environ.get(k)
        if v is not None:
            env_subset[k] = v
    dump["environ_subset"] = env_subset

    return _pretty(dump)

AI_DISCLAIMER_BANNER = """
<style>
#ai-disclaimer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 999999;
    background: #111;
    color: #eee;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    font-size: 14px;
    padding: 10px 16px;
    border-top: 3px solid #dc3545;
    text-align: center;
}
#ai-disclaimer strong {
    color: #ff6b6b;
}
body {
    padding-bottom: 64px; /* prevent content from hiding behind banner */
}
</style>

<div id="ai-disclaimer">
    <strong>AI-Generated Content Warning:</strong>
    This website was generated by artificial intelligence.
    All information may be incorrect, fictional, misleading, or complete nonsense.
    Do not trust or rely on anything you see here.
</div>
"""



def strip_fences(s: str) -> str:
    # Remove common code fences; keep it simple for PoC
    for p in REMOVE_PATTERNS:
        s = s.replace(p, "")
    return s.strip()

@app.route("/<path:path>", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"])
@app.route("/", defaults={"path": ""}, methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"])
def catch_all(path):
    request_dump = build_request_dump()

    prompt = (
        "You are a HTTP server that has become sentient!\n"
        "Return ONLY a complete HTML document (including <html>, <head>, <body>), no markdown.\n"
        "include links to made up pages on the server, iprogrammed it so it can serve anything!\n"
        "You may use Bootstrap (CDN) and JavaScript. and everything else\n"
        "You may not use cookies\n"
        "Dont just do 40x or echo the request.\n"
        "Dont use the alert() function. find an alternative way to send data back to the user\n"
        "never use console.log()\n"
        "Make it fun and engaging for the user\n"
        "Make it ridiculous and incorporate sarcasm and dark humor\n"
        "make it look professional\n"
        "make up content based on the endpoint the user is requesting\n"
        
        "The output will be sent directly to a browser.\n\n"
        "Do not comment on the request, just provide the HTML response.\n\n"
        "=== REQUEST DATA (JSON) ===\n"
        f"{request_dump}\n"
        "=== END REQUEST DATA ===\n"
    )

    response = llm.generate_response(prompt)
    response = strip_fences(response)

    # Inject static disclaimer banner
    if "</body>" in response.lower():
        response = response.replace("</body>", AI_DISCLAIMER_BANNER + "\n</body>")
    else:
        # Fallback: append if body tag is missing/broken
        response += AI_DISCLAIMER_BANNER

    # Force content-type HTML
    return response, 200, {"Content-Type": "text/html; charset=utf-8"}

if __name__ == "__main__":
    # debug=True can execute arbitrary code via the debugger PIN if exposed; keep it local-only.
    app.run(host="0.0.0.0", port=5001, debug=True)
